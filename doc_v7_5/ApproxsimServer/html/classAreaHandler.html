<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Approxsim: AreaHandler class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>AreaHandler Class Reference</h1>Class that finds out which cells a certain shape covers on a certain grid.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="AreaHandler_8h-source.html">AreaHandler.h</a>&gt;</code>
<p>
<a href="classAreaHandler-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#a0">AreaHandler</a> (int rows, int cols, double t, double b, double l, double r, double dx, double dy, double cs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an areahandler for a grid with the specified parameters. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classGridPos.html">GridPos</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#a1">cell</a> (const  <a class="el" href="classProjCoord.html">ProjCoord</a> p) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the position in the grid for the cell that contains the specified point. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#a2">cells</a> (const  <a class="el" href="classPolygon.html">Polygon</a> &amp;inP, std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;outCells) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a list containing the grid positions of all cells covered by the provided <a class="el" href="classPolygon.html">Polygon</a>. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#a3">cells</a> (const  <a class="el" href="classCircle.html">Circle</a> &amp;inC, std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;outCells) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a list containing the grid positions of all cells covered by the provided <a class="el" href="classCircle.html">Circle</a>. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#d0">BuildGET</a> (std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;VertexList, <a class="el" href="structEdgeState.html">EdgeState</a> *NextFreeEdgeStruc, int XOffset, int YOffset) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a Global Edge Table (GET) in the buffer pointed to by NextFreeEdgeStruc from the vertex list. </em> <a href="#d0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#d1">MoveXSortedToAET</a> (int YToMove) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves all edges that start at the specified Y coordinate from the GET to the AET, maintaining the X sorting of the AET. </em> <a href="#d1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#d2">ScanOutAET</a> (int YToScan, std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;outInterior) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills the scan line described by the current AET at the specified Y coordinate. </em> <a href="#d2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="d3" doxytag="AreaHandler::AdvanceAET" ></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#d3">AdvanceAET</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Advances each edge in the AET by one scan line. Removes edges that have been fully scanned. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="d4" doxytag="AreaHandler::XSortAET" ></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#d4">XSortAET</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts all edges currently in the active edge table into ascending order of current X coordinates. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classGridPos.html">GridPos</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#d5">cellPos</a> (double x, double y) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the position in the grid for the cell that contains the specified point. </em> <a href="#d5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classGridPos.html">GridPos</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#d6">cellPos</a> (const  gpc_vertex &amp;p) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the position in the grid for the cell that contains the specified point. </em> <a href="#d6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#d7">borderBetweenRows</a> (int r1, int r2) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the y-coordinate of the line separating the two provided rows. </em> <a href="#d7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#d8">addCellsInCurrentRow</a> (std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;l, int dc) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds specified number of cells in the current row. </em> <a href="#d8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#d9">addCellsInCurrentCol</a> (std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;l, int dr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds specified number of cells in the current column. </em> <a href="#d9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#d10">polygonBoundaryToCellBoundary</a> (gpc_vertex *inP, int inNumPoints, std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;outB) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the cells that a polygon boundary overlaps (not the interior). </em> <a href="#d10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#d11">splitBoundary</a> (const  std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;inB, std::list&lt; std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &gt; &amp;outB) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Splits the provided boundary so that all loops are stored as separate boundaries. </em> <a href="#d11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#d12">getInterior</a> (std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;VertexList, std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;outInterior) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the interior grid positions of the provided exterior. </em> <a href="#d12"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="r0" doxytag="AreaHandler::mRows" ></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#r0">mRows</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of rows in the grid. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="r1" doxytag="AreaHandler::mCols" ></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#r1">mCols</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of columns in the grid. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="r2" doxytag="AreaHandler::mTop" ></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#r2">mTop</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Top coordinate. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="r3" doxytag="AreaHandler::mBottom" ></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#r3">mBottom</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bottom coordinate. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="r4" doxytag="AreaHandler::mLeft" ></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#r4">mLeft</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Leftmost coordinate. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="r5" doxytag="AreaHandler::mRight" ></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#r5">mRight</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rightmost coordinate. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="r6" doxytag="AreaHandler::mDx" ></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#r6">mDx</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The width of a cell. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="r7" doxytag="AreaHandler::mDy" ></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#r7">mDy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The height of a cell. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="r8" doxytag="AreaHandler::mCellSideMeters" ></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classAreaHandler.html#r8">mCellSideMeters</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The cells side in meters. <br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class that finds out which cells a certain shape covers on a certain grid. 
<p>
The algorithm for finding the interior of a polygon is taken from Michel Abrash's Graphics Programming Black Book Special Edition (ISBN 1-57610-174-6).<p>
<dl compact><dt><b>Author:</b></dt><dd>Per Alexius </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd><dl compact><dt><b>Date</b></dt><dd>2005/06/15 09:28:18 </dd></dl>
</dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0" doxytag="AreaHandler::AreaHandler" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> AreaHandler::AreaHandler </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>rows</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>cols</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>l</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>r</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>dx</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>dy</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>cs</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates an areahandler for a grid with the specified parameters. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>rows</em>&nbsp;</td><td>Number of rows in the grid. </td></tr>
    <tr><td valign=top><em>cols</em>&nbsp;</td><td>Number of columns in the grid. </td></tr>
    <tr><td valign=top><em>t</em>&nbsp;</td><td>Top coordinate. </td></tr>
    <tr><td valign=top><em>b</em>&nbsp;</td><td>Bottom coordinate. </td></tr>
    <tr><td valign=top><em>l</em>&nbsp;</td><td>Leftmost coordinate. </td></tr>
    <tr><td valign=top><em>r</em>&nbsp;</td><td>Rightmost coordinate. </td></tr>
    <tr><td valign=top><em>dx</em>&nbsp;</td><td>The width of a cell. </td></tr>
    <tr><td valign=top><em>dy</em>&nbsp;</td><td>The height of a cell. </td></tr>
    <tr><td valign=top><em>cs</em>&nbsp;</td><td>The cells side in meters. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d9" doxytag="AreaHandler::addCellsInCurrentCol" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void AreaHandler::addCellsInCurrentCol </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>l</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>dr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [inline, private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds specified number of cells in the current column. 
<p>
The current column is the column of the last element in the list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>l</em>&nbsp;</td><td>The list which last element indicates the current column and to which to add cells. </td></tr>
    <tr><td valign=top><em>dr</em>&nbsp;</td><td>The number of cells to add - positive for down, negative for up. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d8" doxytag="AreaHandler::addCellsInCurrentRow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void AreaHandler::addCellsInCurrentRow </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>l</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>dc</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [inline, private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds specified number of cells in the current row. 
<p>
The current row is the row of the last element in the list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>l</em>&nbsp;</td><td>The list which last element indicates the current row and to which to add cells. </td></tr>
    <tr><td valign=top><em>dc</em>&nbsp;</td><td>The number of cells to add - positive for right, negative for left. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d7" doxytag="AreaHandler::borderBetweenRows" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double AreaHandler::borderBetweenRows </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>r1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>r2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [inline, private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the y-coordinate of the line separating the two provided rows. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>r1</em>&nbsp;</td><td>The first row. </td></tr>
    <tr><td valign=top><em>r2</em>&nbsp;</td><td>The second row. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The y-coordinate of the line separating the two provided rows. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d0" doxytag="AreaHandler::BuildGET" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void AreaHandler::BuildGET </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>VertexList</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structEdgeState.html">EdgeState</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NextFreeEdgeStruc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>XOffset</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>YOffset</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a Global Edge Table (GET) in the buffer pointed to by NextFreeEdgeStruc from the vertex list. 
<p>
Edge endpoints are flipped, if necessary, to guarantee all edges go top to bottom. The GET is sorted primarily by ascending Y start coordinate, and secondarily by ascending X start coordinate within edges with common Y coordinates<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>VertexList</em>&nbsp;</td><td>A list of vertices. </td></tr>
    <tr><td valign=top><em>NextFreeEdgeStruc</em>&nbsp;</td><td>Allocated memory for all <a class="el" href="structEdgeState.html">EdgeState</a> structs. </td></tr>
    <tr><td valign=top><em>XOffset</em>&nbsp;</td><td>Horizontal offset. </td></tr>
    <tr><td valign=top><em>YOffset</em>&nbsp;</td><td>Verical offset. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="AreaHandler::cell" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classGridPos.html">GridPos</a> AreaHandler::cell </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classProjCoord.html">ProjCoord</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the position in the grid for the cell that contains the specified point. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>p</em>&nbsp;</td><td>The point. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The position in the grid for the cell that contains the specified point. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d6" doxytag="AreaHandler::cellPos" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classGridPos.html">GridPos</a> AreaHandler::cellPos </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const gpc_vertex &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline, private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the position in the grid for the cell that contains the specified point. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>p</em>&nbsp;</td><td>The point. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The position in the grid for the cell that contains the specified point. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d5" doxytag="AreaHandler::cellPos" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classGridPos.html">GridPos</a> AreaHandler::cellPos </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [inline, private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the position in the grid for the cell that contains the specified point. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>x</em>&nbsp;</td><td>The x coordinate of the point. </td></tr>
    <tr><td valign=top><em>y</em>&nbsp;</td><td>The y coordinate of the point. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The position in the grid for the cell that contains the specified point. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="AreaHandler::cells" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void AreaHandler::cells </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classCircle.html">Circle</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>inC</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>outCells</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a list containing the grid positions of all cells covered by the provided <a class="el" href="classCircle.html">Circle</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>inC</em>&nbsp;</td><td>The <a class="el" href="classCircle.html">Circle</a> to get the grid positions for. </td></tr>
    <tr><td valign=top><em>outCells</em>&nbsp;</td><td>A list that on return contains pointers to all cells covered by the provided <a class="el" href="classCircle.html">Circle</a>. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="AreaHandler::cells" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void AreaHandler::cells </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classPolygon.html">Polygon</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>inP</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>outCells</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a list containing the grid positions of all cells covered by the provided <a class="el" href="classPolygon.html">Polygon</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>inP</em>&nbsp;</td><td>The <a class="el" href="classPolygon.html">Polygon</a> to get the grid positions for. </td></tr>
    <tr><td valign=top><em>outCells</em>&nbsp;</td><td>A list that on return contains the grid positions of all cells covered by the provided <a class="el" href="classPolygon.html">Polygon</a>. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d12" doxytag="AreaHandler::getInterior" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int AreaHandler::getInterior </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>VertexList</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>outInterior</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the interior grid positions of the provided exterior. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>VertexList</em>&nbsp;</td><td>A list of grid positions constituting the boundary of the polygon to get the interior for. </td></tr>
    <tr><td valign=top><em>outInterior</em>&nbsp;</td><td>A list of grid positions that on return contains the same values as on entry plus the interior grid positions. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d1" doxytag="AreaHandler::MoveXSortedToAET" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void AreaHandler::MoveXSortedToAET </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>YToMove</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Moves all edges that start at the specified Y coordinate from the GET to the AET, maintaining the X sorting of the AET. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>YToMove</em>&nbsp;</td><td>The y-coordinate for which to move edges. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d10" doxytag="AreaHandler::polygonBoundaryToCellBoundary" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void AreaHandler::polygonBoundaryToCellBoundary </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">gpc_vertex *&nbsp;</td>
          <td class="mdname" nowrap> <em>inP</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>inNumPoints</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>outB</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the cells that a polygon boundary overlaps (not the interior). 
<p>
Does: For each edge in the polygon - check which cells it crosses and store those cells in a linked list. At exit the linked list contains all cells in the boundary in order such that there is an edge between outB[i] and outB[i+1].<p>
Idea: For each line (p1, p2) between the points p1 and p2 do: <p>
Find the cells c1 and c2 that contains the points p1 and p2. <p>
If c1 == c2 <p>
Head on to the next point <p>
Else <p>
Calculate number of rows (dr) and cols (dc) the line passes. <p>
If dr or dc == 0 <p>
We have a trivial case so add edges between cells in the <p>
current row or column between c1 and c2 <p>
Else <p>
For each row that (p1, p2) passes find out in which column c <p>
the intersection is and add edges between all cells on that <p>
row between the current column oldc and c. Also add an edge <p>
between the cells on current row and the next row, in column c. <p>
End <p>
End<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>inP</em>&nbsp;</td><td>The vertices of the polygon. </td></tr>
    <tr><td valign=top><em>inNumPoints</em>&nbsp;</td><td>The number of vertices in the polygon. </td></tr>
    <tr><td valign=top><em>outB</em>&nbsp;</td><td>A list that on return contains the positions of the cells that the provided polygon boundary overlaps. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d2" doxytag="AreaHandler::ScanOutAET" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void AreaHandler::ScanOutAET </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>YToScan</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>outInterior</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fills the scan line described by the current AET at the specified Y coordinate. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>YToScan</em>&nbsp;</td><td>The y-coordinate for which to fill the scan line. </td></tr>
    <tr><td valign=top><em>outInterior</em>&nbsp;</td><td>A list that on return contains the same values as on entry plus the cells on the line just scanned. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d11" doxytag="AreaHandler::splitBoundary" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void AreaHandler::splitBoundary </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>inB</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::list&lt; std::list&lt; <a class="el" href="classGridPos.html">GridPos</a> &gt; &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>outB</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Splits the provided boundary so that all loops are stored as separate boundaries. 
<p>
Does: Splits inB so that all loops are stored as a separate list of cells <p>
in outB. If inB contains no loops the first element in outB will contain <p>
a list identical to inB <p>
Idea: For each cell c in l (l is a copy of inB) <p>
If c was visited before e.g if we have encountered a loop <p>
Store cells that are part of the loop in a new list <p>
Remove all cells that are part of the loop except c from l <p>
Unmark all cells that are part of the loop except c<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>inB</em>&nbsp;</td><td>A list of grid positions constituting a contour of a polygon. </td></tr>
    <tr><td valign=top><em>outB</em>&nbsp;</td><td>A list of lists that on return contains one list of grid positions for each loop found. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="AreaHandler_8h-source.html">AreaHandler.h</a><li>AreaHandler.cpp</ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jan 31 14:27:34 2007 for Approxsim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
